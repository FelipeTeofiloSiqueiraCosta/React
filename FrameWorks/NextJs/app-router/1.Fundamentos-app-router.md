# Criando projeto Next.js

- npx create-next-app@latest
- npm i @rocketseat/eslint-config -D

## Commit

- feat: creating next.js project

# Rotas e layouts

- Todo roteamento é feito através de arquivos
  - Ou seja, toda pasta que eu criar e tiver um arquivo page.tsx dentro, isso vai virar uma página
- O layout.tsx é um arquivo que sempre vai receber um children e apresentar esse children
  - Podemos criar layouts para criar coisas que queremos replicar em muitas páginas

## Commit

- docs: routes and layouts

# Grupos e rotas dinâmicas

_Grupos_

- Imagina que eu tenha duas páginas semelhantes que possuem o mesmo layout
  - sign-in (login)
  - sign-up (registro)
- Teríamos que criar essas estrutura de pasta

  ```shell
    ├── auth
        ├── sign-in
            └── page.tsx
        ├── sign-up
            └── page.ts
        └── layout.tsx
  ```

- Aqui eu teria 2 rotas criadas:
  - /auth/sign-in
  - /auth/sing-up
- porém perceba que o auth está presente nas 2 rotas, e se eu quiser tirar esse auth da rota?

  - é só colocar o nome do arquivo com parênteses em volta, exemplo: (auth)
  - assim ele vai criar um grupo e você não vai precisar colocar /auth/sign-in, somente /sign-in

_Rotas dinâmicas (que aceitam parâmetros)_

- só colocar [] (colchetes) em volta de um nome de pasta

  - exemplo:
    ```shell
    └── product
        └── [id]
            └── page.tsx
    ```
  - então no componente page.tsx você pegaria o parametro assim:

    ```ts
    interface ProductProps {
      params: {
        id: string;
      };
    }

    export default function Product({ params }: ProductProps) {
      return <h1>Hello</h1>;
    }
    ```

  - Caso eu queira receber vários parâmetros é só eu colocar [...data] (tres pontos e o nome que voce quiser) no nome da pasta

## Commit

- docs: groups and dinamic routes

# Arquitetura do Next.js

-Antes de começarmos, vamos entender o contexto de como funcionavam as aplicações tradicionais baseadas em SPA (Single Page Application).

### SPA vs SSR

#### SPA (Single Page Application)

- Em uma SPA, se quisermos fazer uma requisição para uma API, a aplicação precisa ter ao menos um JavaScript básico já carregado no navegador. Esse JS é responsável por fazer a requisição, receber os dados e renderizá-los na tela.
- O problema é que esse modelo traz dificuldades quando o assunto é **indexação no Google**. Os bots/crawlers do Google — que são responsáveis por acessar sites, ler o conteúdo (textos, imagens, links...), entender do que se trata a página e salvar essas informações no índice do Google — geralmente acessam os sites com o JavaScript **desabilitado** ou por **um tempo bem curto**.
- Ou seja: se o conteúdo da sua página depende de uma requisição assíncrona para aparecer, e o bot acessa seu site sem JS ou não espera tempo suficiente, ele **não vê nada**. Resultado? Sua página não é indexada corretamente, ou nem aparece nas buscas.

#### SSR (Server-Side Rendering)

- Foi aí que o Next.js trouxe uma solução muito massa: o **SSR (Server-Side Rendering)**.
- Com SSR, em vez do usuário acessar diretamente uma página front-end (client), ele acessa primeiro um servidor do próprio Next.js — que roda em um ambiente **Node.js**.
- Como o React é apenas JavaScript, e o Node.js consegue rodar JS no lado do servidor, isso significa que o Next.js pode renderizar sua aplicação **antes mesmo do conteúdo chegar no navegador**.
- Funciona assim: quando alguém acessa sua página, o servidor Next.js faz uma requisição à API, recebe os dados, **monta o HTML completo** com essas informações e **envia a página prontinha** para o navegador.
- O resultado? Os bots de indexação vão ver uma página já renderizada, com **todo o conteúdo visível de cara**. Assim, mesmo que o bot tenha o JS desativado ou fique pouco tempo na página, ele já consegue pegar as informações mais importantes para indexar no Google — sem perder nada.

#### SSG (Static Site Generation)

- Imagina que temos um site que exibe uma lista de produtos que só é atualizada a cada 4 horas. Agora pensa: e se **1 bilhão de pessoas** acessarem essa página?
- Se usarmos renderização tradicional no servidor (como o SSR), o Next.js teria que fazer 1 bilhão de requisições para a API, gerar o HTML 1 bilhão de vezes e devolver esse conteúdo para o front-end. É aí que o **SSG** entra como solução.
- Com o SSG, o Next.js gera o HTML de forma estática **apenas uma vez**, durante o processo de build ou com base em uma revalidação agendada. No primeiro acesso após o cache expirar (por exemplo, a cada 4 horas), o servidor faz a requisição para a API, gera o HTML e armazena esse conteúdo em cache.
- Depois disso, qualquer outra pessoa que acessar a mesma página vai receber esse HTML direto do cache, sem precisar passar novamente por todo o processo de geração.

✅ **Vantagens do SSG:**

- Redução extrema da carga no servidor
- Menos requisições para a API
- Carregamento ultra rápido para o usuário
- Escalabilidade absurda com pouco esforço

O resultado? Uma aplicação rápida, eficiente e preparada pra receber milhões (ou bilhões) de acessos com tranquilidade.

# Commit

- docs: next.js architecture

# React Server Components

- Todos os componentes do next.js por padrão são server components

  - São renderizados pelo lado do servidor, então o servidor node retornar no html estático pro cliente
  - Se você precisa que o cliente faça ações como onClick e etc, que o cliente use o JS no lado do client, não vai funcionar usando server-compoents, porque o servidor node retorna um html estático sem JS

- Caso eu queira usar Client-component é só colocar 'use client' no topo do arquivo
  - Basicamente oque next.js faz é o seguinte: Quando a pessoa entra na página, ela bate no servidor node.js do next.js, o servidor node busca os dados html da página, e hidrata esse html com javascript e retornar esse html com o javascript, diferentemente do server-component que retornar um html estático sem js.
    - Você pode perceber que se voce colocar um console.log em um arquivo 'use cliente', você vai perceber que esse console vai aparecer no lado do cliente e no lado do servidor.

## Commit

- docs: react server-components

# Fetch de dados nos componentes

-

## Commit

- feat: data fetch in components

# Loading e Streaming SSR

## Loaging

- Quando temos um component/pagina que demora pra carregar, porque é feita uma request nela como esta:

  ```tsx
  export default async function Home() {
    await new Promise((resolve) => setTimeout(resolve, 2000));

    const response = await fetch(
      "https://api.github.com/users/felipeteofilosiqueiracosta"
    );
    const user = await response.json();

    return <pre>{JSON.stringify(user, null, 2)}</pre>;
  }
  ```

- Podemos adicionar no mesmo nível um outro arquivo chamos loading.tsx, esse arquivo vai ser uma tela que vai mostrar para o usuário uma tela de loading

## Streaming SSR

- Streaming significa ler/escrever dados de forma parcial
- SSR significa Renderização pelo lado do servidor (Server side rendering)
- Streaming SSR significa renderizar componente pelo lado do servidor de forma parcial

- O next.js consegue na mesma requisição ir trazendo os componentes carregador
  - No caso do loading, ele abre uma conexão, retornar a pagina de loading, e ainda na mesma conexão ele retorna a página carregada. Tudo em uma requisição

## Commit

- feat: loading and SSR streaming
