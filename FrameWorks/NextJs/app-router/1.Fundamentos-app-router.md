# Criando projeto Next.js

- npx create-next-app@latest
- npm i @rocketseat/eslint-config -D

## Commit

- feat: creating next.js project

# Rotas e layouts

- Todo roteamento é feito através de arquivos
  - Ou seja, toda pasta que eu criar e tiver um arquivo page.tsx dentro, isso vai virar uma página
- O layout.tsx é um arquivo que sempre vai receber um children e apresentar esse children
  - Podemos criar layouts para criar coisas que queremos replicar em muitas páginas

## Commit

- docs: routes and layouts

# Grupos e rotas dinâmicas

_Grupos_

- Imagina que eu tenha duas páginas semelhantes que possuem o mesmo layout
  - sign-in (login)
  - sign-up (registro)
- Teríamos que criar essas estrutura de pasta

  ```shell
    ├── auth
        ├── sign-in
            └── page.tsx
        ├── sign-up
            └── page.ts
        └── layout.tsx
  ```

- Aqui eu teria 2 rotas criadas:
  - /auth/sign-in
  - /auth/sing-up
- porém perceba que o auth está presente nas 2 rotas, e se eu quiser tirar esse auth da rota?

  - é só colocar o nome do arquivo com parênteses em volta, exemplo: (auth)
  - assim ele vai criar um grupo e você não vai precisar colocar /auth/sign-in, somente /sign-in

_Rotas dinâmicas (que aceitam parâmetros)_

- só colocar [] (colchetes) em volta de um nome de pasta

  - exemplo:
    ```shell
    └── product
        └── [id]
            └── page.tsx
    ```
  - então no componente page.tsx você pegaria o parametro assim:

    ```ts
    interface ProductProps {
      params: {
        id: string;
      };
    }

    export default function Product({ params }: ProductProps) {
      return <h1>Hello</h1>;
    }
    ```

  - Caso eu queira receber vários parâmetros é só eu colocar [...data] (tres pontos e o nome que voce quiser) no nome da pasta

## Commit

- docs: groups and dinamic routes

# Arquitetura do Next.js

-Antes de começarmos, vamos entender o contexto de como funcionavam as aplicações tradicionais baseadas em SPA (Single Page Application).

### SPA vs SSR

#### SPA (Single Page Application)

- Em uma SPA, se quisermos fazer uma requisição para uma API, a aplicação precisa ter ao menos um JavaScript básico já carregado no navegador. Esse JS é responsável por fazer a requisição, receber os dados e renderizá-los na tela.
- O problema é que esse modelo traz dificuldades quando o assunto é **indexação no Google**. Os bots/crawlers do Google — que são responsáveis por acessar sites, ler o conteúdo (textos, imagens, links...), entender do que se trata a página e salvar essas informações no índice do Google — geralmente acessam os sites com o JavaScript **desabilitado** ou por **um tempo bem curto**.
- Ou seja: se o conteúdo da sua página depende de uma requisição assíncrona para aparecer, e o bot acessa seu site sem JS ou não espera tempo suficiente, ele **não vê nada**. Resultado? Sua página não é indexada corretamente, ou nem aparece nas buscas.

#### SSR (Server-Side Rendering)

- Foi aí que o Next.js trouxe uma solução muito massa: o **SSR (Server-Side Rendering)**.
- Com SSR, em vez do usuário acessar diretamente uma página front-end (client), ele acessa primeiro um servidor do próprio Next.js — que roda em um ambiente **Node.js**.
- Como o React é apenas JavaScript, e o Node.js consegue rodar JS no lado do servidor, isso significa que o Next.js pode renderizar sua aplicação **antes mesmo do conteúdo chegar no navegador**.
- Funciona assim: quando alguém acessa sua página, o servidor Next.js faz uma requisição à API, recebe os dados, **monta o HTML completo** com essas informações e **envia a página prontinha** para o navegador.
- O resultado? Os bots de indexação vão ver uma página já renderizada, com **todo o conteúdo visível de cara**. Assim, mesmo que o bot tenha o JS desativado ou fique pouco tempo na página, ele já consegue pegar as informações mais importantes para indexar no Google — sem perder nada.

#### SSG (Static Site Generation)

- Imagina que temos um site que exibe uma lista de produtos que só é atualizada a cada 4 horas. Agora pensa: e se **1 bilhão de pessoas** acessarem essa página?
- Se usarmos renderização tradicional no servidor (como o SSR), o Next.js teria que fazer 1 bilhão de requisições para a API, gerar o HTML 1 bilhão de vezes e devolver esse conteúdo para o front-end. É aí que o **SSG** entra como solução.
- Com o SSG, o Next.js gera o HTML de forma estática **apenas uma vez**, durante o processo de build ou com base em uma revalidação agendada. No primeiro acesso após o cache expirar (por exemplo, a cada 4 horas), o servidor faz a requisição para a API, gera o HTML e armazena esse conteúdo em cache.
- Depois disso, qualquer outra pessoa que acessar a mesma página vai receber esse HTML direto do cache, sem precisar passar novamente por todo o processo de geração.

✅ **Vantagens do SSG:**

- Redução extrema da carga no servidor
- Menos requisições para a API
- Carregamento ultra rápido para o usuário
- Escalabilidade absurda com pouco esforço

O resultado? Uma aplicação rápida, eficiente e preparada pra receber milhões (ou bilhões) de acessos com tranquilidade.

# Commit

- docs: next.js architecture

# React Server Components

- Todos os componentes do next.js por padrão são server components

  - São renderizados pelo lado do servidor, então o servidor node retornar no html estático pro cliente
  - Se você precisa que o cliente faça ações como onClick e etc, que o cliente use o JS no lado do client, não vai funcionar usando server-compoents, porque o servidor node retorna um html estático sem JS

- Caso eu queira usar Client-component é só colocar 'use client' no topo do arquivo
  - Basicamente oque next.js faz é o seguinte: Quando a pessoa entra na página, ela bate no servidor node.js do next.js, o servidor node busca os dados html da página, e hidrata esse html com javascript e retornar esse html com o javascript, diferentemente do server-component que retornar um html estático sem js.
    - Você pode perceber que se voce colocar um console.log em um arquivo 'use cliente', você vai perceber que esse console vai aparecer no lado do cliente e no lado do servidor.

## Commit

- docs: react server-components

# Fetch de dados nos componentes

-

## Commit

- feat: data fetch in components

# Loading e Streaming SSR

## Loaging

- Quando temos um component/pagina que demora pra carregar, porque é feita uma request nela como esta:

  ```tsx
  export default async function Home() {
    await new Promise((resolve) => setTimeout(resolve, 2000));

    const response = await fetch(
      "https://api.github.com/users/felipeteofilosiqueiracosta"
    );
    const user = await response.json();

    return <pre>{JSON.stringify(user, null, 2)}</pre>;
  }
  ```

- Podemos adicionar no mesmo nível um outro arquivo chamos loading.tsx, esse arquivo vai ser uma tela que vai mostrar para o usuário uma tela de loading

## Streaming SSR

- Streaming significa ler/escrever dados de forma parcial
- SSR significa Renderização pelo lado do servidor (Server side rendering)
- Streaming SSR significa renderizar componente pelo lado do servidor de forma parcial

- O next.js consegue na mesma requisição ir trazendo os componentes carregador
  - No caso do loading, ele abre uma conexão, retornar a pagina de loading, e ainda na mesma conexão ele retorna a página carregada. Tudo em uma requisição

## Commit

- feat: loading and SSR streaming

# Abstraindo client components

- Hoje o componente: ./app/catalog/product/[id]/page.tsx só é um client componente porque ele tem um event listener (um js para possibilitar a interação do usuário (onClick)) e porque tem um estado do react (useState).

  - Exemplo:

    ```tsx
    "use client";

    import { useState } from "react";

    export default function Product({ params }: { params: { id: string } }) {
      const [count, setCount] = useState(0);

      //const response = await fetch(`/api/product/${params.id}`)

      function handleAddToCart() {
        setCount((state) => state + 1);
      }

      return (
        <div>
          {count}
          prod: {params.id} <button onClick={handleAddToCart}></button>
        </div>
      );
    }
    ```

  - Nesse exemplo, eu preciso buscar os dados do produto no banco usando o id da rota. No entanto, como esse componente é um Client Component (repare no "use client" no topo), eu não posso usar await fetch() diretamente no corpo do componente para fazer uma chamada assíncrona de forma síncrona (como faria em um Server Component com async/await fora de efeitos ou handlers).

  - Outro detalhe importante: somente o botão precisa de interatividade com JavaScript (estado com useState). O resto do componente apenas exibe dados — o que poderia ser feito tranquilamente no servidor.

  - Por isso, uma boa prática aqui seria separar o botão em um Client Component isolado, deixando o componente principal como Server Component, que pode fazer fetch direto no banco via async/await.
    - separei em um arquivo chamado add-to-cart-button.tsx

## Commit

- feat: abstracting client components

# Client Boundaries e Encadeamento

## Client Boundaries

- A partir do momento que eu declaro um component com 'use client', todos os filhos dele serão componentes client também

  - Exemplo:

    ```tsx
    //./add-to-cart-button.tsx (component pai)
    "use client";
    import React, { useState } from "react";
    import { TestClient } from "./test";

    export function AddToCartButton() {
      const [count, setCount] = useState(0);

      function handleAddToCart() {
        setCount((state) => state + 1);
      }

      return (
        <div>
          {count}
          <br />
          <button onClick={handleAddToCart}>Adicionar ao carrinho</button>
          <TestClient /> //component filho
        </div>
      );
    }

    //./test.tsx (component filho)
    import React, { useState } from "react";

    export function TestClient() {
      const [state, setState] = useState(0);

      function addState() {
        setState((state) => state + 1);
      }

      return (
        <div>
          <button onClick={addState}>{state} Component client</button>
        </div>
      );
    }
    ```

  - Perceba que o componente filho nem precisou da definição do 'use client' no podo do arquivo, o next.js automaticamente soube que ele era um client-component porque o componente pai era um client-component
    - Eu não posso tratar esse componente como um server-side, se ele estiver dentro de um client-side dessa forma

## Encadeamento

- Mas e se eu quisesse que meu componente TestClient, fosse um server-component, teria como?

  - Sim, a única forma que exite atualmente é renderizando esse componente server-side, por meio de um children, passando ele como parâmetro.

    - Exemplo:

      ```tsx
      // test.tsx server-component
      export async function TestClient() {
        await new Promise(function (resolve) {
          setTimeout(resolve, 2000);
        });
        return (
          <div>
            <h1 className="font-bold">
              Server component inside of client-component
            </h1>
          </div>
        );
      }

      // add-to-cart-button.tsx (client-component)
      ("use client");
      import React, { useState, type ReactNode } from "react";

      export function AddToCartButton({ children }: { children: ReactNode }) {
        const [count, setCount] = useState(0);

        function handleAddToCart() {
          setCount((state) => state + 1);
        }

        return (
          <div>
            {count}
            <br />
            <button onClick={handleAddToCart}>Adicionar ao carrinho</button>
            {children} // renderizando server-component
          </div>
        );
      }

      // page.tsx (server-component)
      import { AddToCartButton } from "./add-to-cart-button";
      import { TestClient } from "./test";

      export default async function Product({
        params,
      }: {
        params: { id: string };
      }) {
        // agora você pode fazer um fetch aqui
        const { product } = await new Promise<{
          product: { name: string; qte: number };
        }>((resolve) =>
          setTimeout(
            () => resolve({ product: { name: "camiseta", qte: 2 } }),
            2000
          )
        );

        return (
          <div>
            <p>{params.id}</p>
            <p>{product.name}</p>
            <p>{product.qte}</p>
            <br />
            <AddToCartButton>
              <TestClient /> // passando server-component como filho
            </AddToCartButton>
          </div>
        );
      }
      ```

## Commit

- feat: Client Boundaries and Chaining

# Suspense API no React

- No Next.js, por padrão, os componentes server-side são renderizados no servidor antes da página ser enviada ao navegador. Isso significa que, se você tem um componente pai que depende de um componente filho server-side async, o pai vai esperar o filho terminar toda sua execução (incluindo chamadas fetch, consultas ao banco de dados, etc) antes de renderizar a página para o usuário.

- Ou seja, o Next.js não começa a enviar nada pro navegador até que toda a árvore de componentes server-side esteja pronta, da raiz até o último async lá embaixo. Esse comportamento garante que o usuário receba a página já com os dados completos — mas também pode causar atrasos na renderização se algum componente demorar pra responder.

- Exemplo:

  ```tsx
  // page.tsx (server-side) pai
  import { GithubProfile } from "./components/github-profile";

  export default async function Home() {
    return (
      <div>
        <h1>Home</h1>
        <p>Descrição da home e outros componentes </p>
        <GithubProfile /> // componente server-side filho
      </div>
    );
  }

  // githuv-prodile.tsx (server-side) filho
  export async function GithubProfile() {
    await new Promise((resolve) => setTimeout(resolve, 2000));

    const response = await fetch(
      "https://api.github.com/users/felipeteofilosiqueiracosta"
    );
    const user = await response.json();

    return <pre>{JSON.stringify(user, null, 2)}</pre>;
  }
  ```

- Perceba que, no exemplo acima, o componente pai (page.tsx) vai aguardar o carregamento completo do componente filho (GithubProfile) — incluindo todas as requisições que ele precisa fazer — antes de exibir qualquer coisa na tela.

- Mas faz sentido isso?

- O pai pode ter outras informações estáticas, como um h1, um p, ou até mesmo conteúdo que não depende de nenhuma chamada assíncrona. Esses elementos não deveriam precisar esperar o carregamento do componente filho para aparecer. O ideal seria que o Next.js mostrasse imediatamente o que já está pronto e deixasse o conteúdo assíncrono ser carregado de forma independente.

  - Nesse caso podemos usar a suspense API
  - Exemplo

    ```tsx
    import { Suspense } from "react";
    import { GithubProfile } from "./components/github-profile";

    export default async function Home() {
      return (
        <div>
          <h1>Home</h1>
          <p>Descrição da home e outros componentes</p>
          <Suspense fallback={<h1>Carregando perfil do github...</h1>}>
            <GithubProfile />
          </Suspense>
        </div>
      );
    }
    ```

  - Agora vai ser renderizado "Carregando perfil do github...", na home enquanto o componente server-side GithubProfile estiver em loading, e a página home não vai esperar.

## Commit

- feat: react suspense API
